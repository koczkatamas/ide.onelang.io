extension: go
casing:
  class: pascal_case
  method: pascal_case
primitiveTypes:
  void: ""
  boolean: bool
  string: string
  number: int
array: '[]{{type}}'
functions:
  OneConsole.print:
    includes: [fmt]
    template: "fmt.Println({{str}})"
  OneArray.add:
    template: "{{self}} = append({{self}}, {{item}})"
  OneArray.length:
    template: "len({{self}})"
  OneArray.get:
    template: "{{self}}[{{index}}]"
  OneArray.set:
    template: "{{self}}[{{index}}] = {{value}}"
  OneMap.keys:
    extraArgs: [result]
    template: |-
      {{result}} := make([]{{typeArgs[0]}}, 0, len({{self}}))
      for  key, _ := range {{self}} {
        {{result}} = append({{result}}, key)
      }
  OneMap.values:
    extraArgs: [result]
    template: |-
      {{result}} := make([]{{typeArgs[1]}}, 0, len({{self}}))
      for  _, value := range {{self}} {
        {{result}} = append({{result}}, value)
      }
  OneMap.remove:
    template: "delete({{self}}, {{key}})"
  OneMap.hasKey:
    extraArgs: [result]
    template: "_, {{result}} := {{self}}[{{key}}]"
  OneMap.get:
    template: "{{self}}[{{key}}]"
  OneMap.set:
    template: "{{self}}[{{key}}] = {{value}}"
templates:
  testGenerator: |-
    func main() {
        c := ({{class}}{})
        fmt.Println(c.{{method}}())
    }

  main: |-
    package main

    {{for inc in includes|sep=\n}}
      import "{{inc}}"
    {{/for}}

    {{for class in classes|sep=\n\n}}
      type {{class.name}} struct {
          {{for field in class.fields|sep=\n}}
            {{field.name}} {{getType(field)}}
          {{/for}}
      }

      {{for method in class.methods|sep=\n\n}}
        func (this *{{class.name}}) {{method.name}}({{genArgs(method)}}) {{method.returnType}} {
            {{genBody(method.body)}}
        }
      {{/for}}
    {{/for}}

  getType:
    args:
      - name: item
    template: "{{if item.typeInfo.isClass}}*{{/if}}{{item.type}}"

  genBody:
    args:
      - name: body
    template: |-
      {{for statement in body.statements|sep=\n}}
        {{statement.leadingTrivia}}{{gen(statement)}}
      {{/for}}

  genArgs:
    args:
      - name: method
    template: |-
      {{for param in method.parameters|sep=", "}}
        {{param.name}} {{param.type}}
      {{/for}}
  genParams:
    args:
      - name: params
    template: |-
      {{for param in params|sep=", " inline}}
        {{gen(param)}}
      {{/for}}
  genVar:
    args:
      - name: itemVar
    template: "{{itemVar.name}} := {{gen(itemVar.initializer)}}"
expressions:
  call: |-
    {{gen(expr.method)}}(
      {{for arg in expr.arguments|sep=", " inline}}
        {{gen(arg)}}
      {{/for}}
    )
  propertyAccess: "{{gen(expr.object)}}.{{gen(expr.propertyName)}}"
  identifier: "{{expr.text}}"
  stringLiteral: "\"{{expr.value}}\""
  nullLiteral: "nil"
  return: "return {{gen(expr.expression)}}"
  binary: "{{gen(expr.left)}} {{expr.operator}} {{gen(expr.right)}}"
  postfix: "{{gen(expr.operand)}}{{expr.operator}}"
  prefix: "{{expr.operator}}{{gen(expr.operand)}}"
  parenthesized: "({{gen(expr.expression)}})"
  numericLiteral: "{{expr.value}}"
  variableDeclaration: "{{genVar(expr)}}"
  new: "{{gen(expr.class)}}{{{genParams(expr.arguments)}}}"
  classReference: "{{expr.classRef.name}}"
  arrayLiteral: "[]{{expr.typeArgs[0]}}{{{genParams(expr.items)}}}"
  mapLiteral: |- 
    map[{{expr.typeArgs[0]}}]{{expr.typeArgs[1]}}{
      {{for prop in expr.properties|sep="\n"}}
        "{{prop.name}}": {{gen(prop.initializer)}},
      {{/for}}
    }
  expressionStatement: "{{gen(expr.expression)}}"
  instanceMethod: "{{gen(expr.thisExpr)}}.{{expr.methodRef.name}}"
  staticMethod: "{{expr.methodRef.classRef.name}}.{{expr.methodRef.name}}"
  localVar: "{{expr.varRef.name}}"
  methodArgument: "{{expr.varRef.name}}"
  instanceField: "{{gen(expr.thisExpr)}}.{{expr.varRef.name}}"
  falseLiteral: "false"
  trueLiteral: "true"
  elementAccess: "{{gen(expr.object)}}[{{gen(expr.elementExpr)}}]"
  thisReference: this
  foreach: |-
    for _, {{expr.itemVariable.name}} := range {{gen(expr.items)}} {
        {{genBody(expr.body)}}
    }
  for: |-
    for {{genVar(expr.itemVariable)}}; {{gen(expr.condition)}}; {{gen(expr.incrementor)}} {
        {{genBody(expr.body)}}
    }
  if: |-
    if {{gen(expr.condition)}} {
        {{genBody(expr.then)}}
    }
    {{if expr.else|inline}}
      {{if isIfBlock(expr.else)}}
        \ else\ {{genBody(expr.else)|inline}}
      {{else}}
        \ else {
            {{genBody(expr.else)}}
        }
      {{/if}}
    {{/if}}
